# CT33--存储层次

## 存储层次（Memory Hierarchy）

## 局部性原理

## 虚拟地址空间

自 20 世纪 40 年代以来，计算机的基础架构已逐渐形成标准，包括处理器、用于存储指令和数据的内存、以及输入输出设备。这一架构通常称为**冯·诺依曼架构**（Von Neumann Architecture），以数学家与计算机科学家约翰·冯·诺依曼（John von Neumann，1903 年 12 月 28 日－1957 年 2 月 8 日）的名字命名。他在 1946 年发表的论文中首次系统描述了这种架构。论文开篇用现代术语来解释，就是：**CPU** 负责算法和控制，**RAM** 与磁盘承担数据与指令存储，而键盘、鼠标、显示器等则与操作人员交互。
​
在这一架构中，与存储相关的进程的**虚拟地址空间**是需要重点理解的部分。

**虚拟存储器**（Virtual Memory）是一种抽象机制，它为每个进程提供了一个假象——仿佛自己独占全部主存。实际上，所有进程都看到相同且连续的内存布局，这个抽象的内存视图称为**虚拟地址空间**。

如下图所示，一个典型 Linux 进程的虚拟地址空间（其他 Unix 系统类似）。在 Linux 中，最高四分之一的地址空间保留给内核代码与数据，这对所有进程都一样；其余四分之三则分配给用户进程的代码与数据。需要注意的是，图中的内存地址是**自下而上递增**的。

![进程的虚拟地址空间](./CT3x.assets/CT33--vm-001.png)

$$\color{blue}{图：进程的虚拟地址空间（注：图片来源为 Randal Bryant，2015年3月）}$$

每个进程的虚拟地址空间由一系列功能明确的**区域（area）**构成。按照地址从低到高，大致可以分为以下几个部分：

1. **程序代码与数据（Code and Data）**
   程序代码从固定地址开始，紧接其后的数据区存放全局变量等。它们由可执行文件直接初始化，例如示例程序 `hello` 的可执行文件。
2. **堆（Heap）**
   位于代码和数据区之后，是**运行时堆**（Run-time Heap）。与启动时大小固定的代码与数据区不同，堆的大小可在程序运行过程中动态变化，例如通过 C 标准库函数 `malloc` 和 `free` 来分配或释放内存。
3. **共享库（Shared Libraries）**
   位于地址空间中部，用于存放共享库（如标准 C 库、数学库等）的代码与数据。这一机制允许多个进程共享相同的库文件，从而节省内存并便于更新。
4. **栈（Stack）**
   位于用户虚拟地址空间顶部，用于函数调用与局部变量存储。与堆一样，用户栈（User Stack）在程序执行时可动态扩展或收缩——函数调用时栈增长，函数返回时栈缩小。
5. **内核虚拟存储器（Kernel Virtual Memory）**
   占据地址空间最顶端，存放内核常驻代码和数据。用户程序不能直接访问这一区域，也不能调用内核定义的函数。

虚拟存储器的实现依赖于**硬件与操作系统的紧密协作**，包括对处理器生成的每一个地址进行硬件级翻译。核心思想是：将进程的虚拟内存内容保存在磁盘上，并利用主存作为磁盘的高速缓存，从而在保证进程隔离的同时提高访问效率。

### Python程序的虚存布局

virtual_meomory.py

```python
import sys

print("==== 冯·诺依曼架构：Python 进程的虚拟地址空间演示 ====\n")

# 1. —— 代码区（Code Segment） ——————————————————————
def code_function():
    return 1

print("[代码区] 函数对象地址:", hex(id(code_function)))

# 2. —— 数据区（Global / Static Data Segment） ——————————
GLOBAL_VAR = 12345
print("[数据区] 全局变量地址:", hex(id(GLOBAL_VAR)))


# 3. —— 堆（Heap）动态分配 ——————————————————————
a = [1, 2, 3, 4]   # list 对象由 Python 运行时在堆上分配
b = {"name": "von Neumann"}
print("[堆] list 对象地址:", hex(id(a)))
print("[堆] dict 对象地址:", hex(id(b)))


# 4. —— 栈（Stack Frame） ————————————————————————
def stack_demo(depth):
    x = depth * 10
    print(f"[栈] depth={depth} 的局部变量 x 地址:", hex(id(x)))
    if depth > 0:
        stack_demo(depth - 1)

print()
stack_demo(2)


# 5. —— 展示虚拟地址空间是 “连续、统一” 的抽象 ————————
print("\n==== 地址空间连续性展示 ====")
items = [
    ("代码区", id(code_function)),
    ("数据区", id(GLOBAL_VAR)),
    ("堆(list)", id(a)),
    ("堆(dict)", id(b)),
]

for name, addr in items:
    print(f"{name:<10} -> {hex(addr)}")

print("\n注意：虽然这些地址看似很大，但它们都属于同一个 64-bit 进程的虚拟地址空间。")
print("不同区域看上去杂乱，但操作系统和 CPU 通过页表完成了真正的物理内存映射。")

```

mac机器运行显示

```text
==== 冯·诺依曼架构：Python 进程的虚拟地址空间演示 ====

[代码区] 函数对象地址: 0x1003c9da0
[数据区] 全局变量地址: 0x100246150
[堆] list 对象地址: 0x100327600
[堆] dict 对象地址: 0x100361e80

[栈] depth=2 的局部变量 x 地址: 0x100e96260
[栈] depth=1 的局部变量 x 地址: 0x100e96120
[栈] depth=0 的局部变量 x 地址: 0x100e95fe0

==== 地址空间连续性展示 ====
代码区        -> 0x1003c9da0
数据区        -> 0x100246150
堆(list)    -> 0x100327600
堆(dict)    -> 0x100361e80

注意：虽然这些地址看似很大，但它们都属于同一个 64-bit 进程的虚拟地址空间。
不同区域看上去杂乱，但操作系统和 CPU 通过页表完成了真正的物理内存映射。
```

clab 上 RockyLinux 运行显示

```text
==== 冯·诺依曼架构：Python 进程的虚拟地址空间演示 ====

[代码区] 函数对象地址: 0x7fe7f522a1f0
[数据区] 全局变量地址: 0x7fe7f4d90b50
[堆] list 对象地址: 0x7fe7f4d80c40
[堆] dict 对象地址: 0x7fe7f4df5640

[栈] depth=2 的局部变量 x 地址: 0x7fe7f527cb90
[栈] depth=1 的局部变量 x 地址: 0x7fe7f527ca50
[栈] depth=0 的局部变量 x 地址: 0x7fe7f527c910

==== 地址空间连续性展示 ====
代码区        -> 0x7fe7f522a1f0
数据区        -> 0x7fe7f4d90b50
堆(list)    -> 0x7fe7f4d80c40
堆(dict)    -> 0x7fe7f4df5640

注意：虽然这些地址看似很大，但它们都属于同一个 64-bit 进程的虚拟地址空间。
不同区域看上去杂乱，但操作系统和 CPU 通过页表完成了真正的物理内存映射
```
