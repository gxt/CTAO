# 以数为纲

!!! abstract https://en.wikipedia.org/wiki/John_Archibald_Wheeler#It_from_bit

    **It from bit.**
    
    John Archibald Wheeler：约翰·阿奇博尔德·惠勒（1911年7月9日—2008年4月13日）是20世纪最具影响力的美国理论物理学家之一，以在广义相对论、量子引力、黑洞物理及核物理领域的开创性贡献著称，同时是著名教育家，培养了多位诺贝尔物理学奖得主。

    `It from Bit`的字面含义是：**宇宙中的一切事物都源于信息的基本单位**，or **一切源于比特**，or **万物皆比特**（It，指物质、能量、时空等客观存在；Bit，即二进制位，代表“是”或“否”的判断）。
    
    惠勒认为，**信息是宇宙的本质**，物理世界的“实在性”并非先于观察存在，而是由观察者与系统的 **互动（测量）** ​所产生的“比特信息”构建而成。

    `It from Bit`是惠勒对宇宙本质的终极追问：**宇宙的一切（It）都源于信息（Bit），而信息的获取（测量）离不开观察者的参与。** 这一概念不仅深化了对量子力学的理解，也为探索“量子引力”提供了哲学指引，被誉为“21世纪物理学的灯塔”。

## 比特

!!! info https://en.wikipedia.org/wiki/Bit

    **bit**（比特，或位）是计算和数字通信中最基本的信息单位。其名称是“二进制数字”（binary digit）的合成词。
    
    比特代表一种逻辑状态，具有两种可能值之一。这些值最常用 `1` 和 `0` 表示，但真/假、是/否、开/关、正/负等其他表示方式也被广泛使用。

    一组连续的二进制数字通常称为 `bit string`、`bit vector`或一维（或多维）`bit array`。
    
    四位二进制数字串通常称为一个`nibble`，八位二进制数字组合称为一个字节（**byte**），但从历史上看，字节的大小并未被严格定义。
    
**位（bit）** 是计算机中最小的数据单位，只能取值 0 或 1，通常用于表示某种状态，例如：1 表示开关接通，0 表示断开。位可以组成序列来表示各种数据，这个由 0 和 1 组成的序列就称为 **位模式**。当位数为 8 时，这个序列被称为 **1 字节（byte）**。

计算机外部的各种数据类型（Text, Number, Image, Audio, Video）在存储前，都会转换为统一的表示形式，再存入计算机；输出时再将其还原。这种通用的表示形式称为 **位模式（bit pattern）**。

![不同数据类型的存储](./CT2x.assets/CT21--bit-001.png)

$$\color{blue}{图：不同数据类型的存储方式}$$

任何集合，由各种符号组成，而每个符号都可以用一个位模式表示。表示一个符号所需的位数取决于该语言中符号的总数量，如下表所示。

$\color{blue}{表：表示不同符号数量所需的位模式长度}$

| 符号数量 | 位模式长度 |
| -------- | ------------ |
| 2        | 1            |
| 4        | 2            |
| 8        | 3            |
| 16       | 4            |
| 256      | 8            |
| 65536    | 16           |

为了让符号与位模式一一对应，人们设计了不同的 **代码表**，这种将符号映射为位模式的过程称为**编码**。

所有计算机外部的数据类型的数据都采用统一的数据表示法转换后存入计算机中，当数据从计算机输出时再还原回来。这种通用的格式称为位模式。

**1. 位**

位（bit, binary digit的缩写）是存储在计算机中的最小单位，它是0或1。位代表设备的某一状态，这些设备只能处于两种状态之一。例如，开关要么合上要么断开。用1表示合上状态，0表示断开状态。电子开关就表示一个位。换句话说，一个开关能存储一个位的信息。今天，计算机使用各种各样的双态设备来存储数据。

**2. 位模式**

为了表示数据的不同类型，应该使用位模式，它是一个序列，有时也称为位流。展示了由16个位组成的位模式。它是0和1的组合。这就意味着，如果我们需要存储一个由16个位组成的位模式，那么需要16个电子开关。如果我们需要存储1000个位模式，每个16位，那么需要16 000个开关。通常长度为8的位模式被称为1个字节（byte）。有时用字（word）这个术语指代更长的位模式。


## 进制转换

**位置化数字系统**中，在数字中符号所占据的位置决定了其表示的值。

下表是四种位置化系统（十进制、二进制、八进制和十六进制）的小结。

$\color{blue}{表：4种位置化系统的小结}$

| 系统     | 底   | 符号                                           | 例子            |
| -------- | ---- | ---------------------------------------------- | --------------- |
| 十进制   | 10   | 0, 1, 2, 3, 4, 5, 6, 7, 8, 9                   | 2345.56         |
| 二进制   | 2    | 0, 1                                           | $(1001.11)_2$   |
| 八进制   | 8    | 0, 1, 2, 3, 4, 5, 6, 7                         | $(156.23)_8$    |
| 十六进制 | 16   | 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F | $(A2C.A1)_{16}$ |

下表显示了数字15在十进制中使用2个数码，在二进制中使用4个数码，在八进制中使用2个数码，在十六进制中仅仅使用1个数码。十六进制表示法显然是最短的。

$\color{blue}{表：4种位置化系统中的数字比较}$

| 十进制 | 二进制 | 八进制 | 十六进制 | 十进制 | 二进制 | 八进制 | 十六进制 |
| ------ | ------ | ------ | -------- | ------ | ------ | ------ | -------- |
| 0      | 0      | 0      | 0        | 8      | 1000   | 10     | 8        |
| 1      | 1      | 1      | 1        | 9      | 1001   | 11     | 9        |
| 2      | 10     | 2      | 2        | 10     | 1010   | 12     | A        |
| 3      | 11     | 3      | 3        | 11     | 1011   | 13     | B        |
| 4      | 100    | 4      | 4        | 12     | 1100   | 14     | C        |
| 5      | 101    | 5      | 5        | 13     | 1101   | 15     | D        |
| 6      | 110    | 6      | 6        | 14     | 1110   | 16     | E        |
| 7      | 111    | 7      | 7        | 15     | 1111   | 17     | F        |

在十进制系统中，底 `b=10` 并且用10个符号来表示一个数。该系统中的符号常被称为十进制数码或仅称为数码。

在二进制系统中，底 `b=2` 并且用2个符号来表示一个数。该系统中的符号常被称为二进制数码或位。

在十六进制系统中，底 `b=16` 并且用16个符号来表示一个数。该系统中的符号常被称为十六进制数码。

在八进制系统中，底 `b=8` 并且用8个符号来表示一个数。该系统中的符号常被称为八进制数码。

可以从任意底转换到十进制。将数码乘以其在源系统中的位置量并求和便得到在十进制中的数。

能够将十进制数转换到与其等值的任意底。需要两个过程：一是用于整数部分，另一个是用于小数部分。<mark>整数部分需要连除，而小数部分需要连乘</mark>。

将数字从二进制转换到十六进制很容易，反之亦然。这是因为<mark>二进制中的4位恰好是十六进制中的1位</mark>。

将数字从二进制转换到八进制很容易，反之亦然。这是因为<mark>二进制中的3位恰好是八进制中的1位</mark>。

### 十进制 - 二进制

!!! example **例** 将十进制数0.625转换为二进制数。

    解 因为0.625没有整数部分，该例子显示小数部分如何计算。这里是以2为底。在左边一角写上这个十进制数。连续乘2，并记录结果的整数和小数部分。小数部分移到右边，整数部分写在每次运算的下面。当小数部分为0，或达到足够的位数时结束。结果是0.625 = (0.101)₂。

    ```
    十进制    0.625 → 0.25 → 0.50 → 0.00
               ↓       ↓       ↓  
    二进制  .  1       0       1
    ```

!!! example **例** 下面演示如何将0.634转换为八进制数且精确到小数4位。结果是0.634 = (0.5044)₈。

    ```
    十进制    0.634 → 0.072 → 0.576 → 0.608 → 0.864
               ↓       ↓       ↓       ↓
    八进制  .  5       0       4       4
    ```

!!! example **例** 下面演示如何将十进制数178.6转换为十六进制数，且精确到1位小数。结果是178.6 = (B2.9)₁₆。注意，以16为底时除或乘以16。

    ```
    十进制    0 ← 11 ← 178    0.6 → 0.6
                   ↓     ↓       ↓
    十六进制        B     2   .   9
    ```

把小的十进制数（通常小于256）转换为二进制数有一个变通的方法，即把这个数分解为下列二进制位置量对应数的和。

```
位置量          2⁷   2⁶  2⁵  2⁴  2³  2²  2¹  2⁰
十进制对等量    128  64  32  16  8   4   2   1
```

使用该表可以转换165为二进制数(10100101)₂，如下所示：

```
十进制 165 = 128 + 0 + 32 + 0 + 0 + 4 + 0 + 1
二进制         1   0   1    0   0   1   0   1
```

当分母是2的幂次时，用类似的方法可以把十进制数小数转换为二进制。

```
位置量        2⁻¹  2⁻²  2⁻³  2⁻⁴  2⁻⁵  2⁻⁶  2⁻⁷
十进制对等量  1/2  1/4  1/8  1/16 1/32 1/64 1/128
```

使用该表可以转换27/64为二进制数(0.011011)₂，如下所示：

```
十进制 27/64 = 16/64 + 8/64 + 2/64 + 1/64
              1/4   + 1/8   + 1/32 + 1/64
```

根据十进制对等的值排列这些分数:

```
十进制 27/64 =  0  +  1/4  +  1/8  +  0  +  1/32  +  1/64
二进制          0      1       1      0      1        1
```

### 二进制 - 十六进制

我们能轻松将数字从二进制转换到十六进制，反之亦然。这是因为在这两个进制之间存在一种关系：二进制中的4位恰好是十六进制中的1位。

!!! example **例** 下面演示如何将二进制数$(10011100010)_2$转换为十六进制数。

    **解** 我们先将二进制数排为4位一组的形式：100 1110 0010。注意最左边一组可能是1到4位不等。我们根据表2-2所示的值对照每组等量转换得到十六进制数$(4E2)_{16}$。

!!! example **例** 与十六进制数$(24C)_{16}$相等的二进制数是多少？

    **解** 将每个十六进制数码转换成4位一组的二进制数：2→0010，4→0100，以及C→1100。该结果是$(001001001100)_2$。

> 在二进制表示中，前面的零（即前导零）是可以去掉的，因为它们并不改变数值的大小。如果题目明确问内存中的表示形式，不能去掉前导零。

### 二进制 - 八进制

!!! example **例** 下面演示如何将二进制数$(101110010)_2$转换为八进制数。

    **解** 每3位一组转换为1位八进制数码。根据表2-2所示的值对照每3位一组等量转换得到八进制数结果是$(562)_8$。

!!! example **例** 与$(24)_8$相等的二进制数是多少？

    **解** 将每个八进制数码写成对等的二进制位组，得到$(010100)_2$。

### 八进制 - 十六进制

将数字从八进制转换到十六进制并不难，反之亦然。可以使用二进制系统作为中介系统。

该步骤如下：

- 从八进制转到十六进制，先将八进制转到二进制。将位数重排成4位一组，找到十六进制的对等值。
- 从十六进制转到八进制，先将十六进制转到二进制。将位数重排成3位一组，找到八进制的对等值。


## 整数

**存储数字**

在存储到计算机内存中之前，数字被转换为二进制系统。但是，这里还有两个问题需要解决：

1) 如何存储数字的符号。
2) 如何显示十进制小数点。

整数是完整的数字（即没有小数部分）。例如，134和-125是整数而134.23和-0.235则不是。整数可以被当作小数点位置固定的数字：小数点固定在最右边。因此，定点表示法用于存储整数。在这种表示法中，小数点是假定的，但并不存储。

但是，用户（或程序）可能将整数作为小数部分为0的实数存储。这是可能发生的，例如，整数太大以至于无法定义为整数来存储。为了更有效地利用计算机内存，无符号和有符号的整数在计算机中存储方式是不同的。

**整数通常使用定点表示法存储在内存中。**

### 无符号表示法

无符号整数就是没有符号的整数。它的范围介于0到无穷大之间。然而，由于计算机不可能表示这个范围的所有整数，通常，计算机都定义了一个最大无符号整数的常量，称为最大无符号整数，它的值是 \((2^n - 1)\)。这里 \(n\) 就是计算机中分配用于表示无符号整数的二进制位数。

**(1) 存储无符号整数**

使用以下步骤输入存储无符号整数：

- 首先将整数变成二进制数。
- 如果二进制位数不足 \(n\) 位，则在二进制整数的左边补0，使它的总位数为 \(n\) 位。如果位数大于 \(n\)，该整数无法存储。导致溢出的情况发生，我们后面要讨论这方面内容。

!!! example **例** 将7存储在8位存储单元中。

    解 首先将整数转换为二进制数 $(111)_2$。加5个0使总的位数为8位，即 $(00000111)_2$。再将该整数保存在存储单元中。注意，右下角的2用于强调该整数是二进制的，并不存储在计算机中。

    把7变为二进制  →   1 1 1

    在左边加5位    → 0 0 0 0 0 1 1 1

!!! example **例** 将258存储在16位存储单元中。

    解 首先把整数转换为二进制 $(100000010)_2$，加7个0使总的位数满足16位的要求，即得到 $(0000000100000010)_2$。再将该整数被存储在存储单元中。

    把258变为二进制 →    1 0 0 0 0 0 0 0 1 0

    在左边加7位     →   0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0

**(2) 译解无符号整数**

输出设备译解内存中位模式的位串并转换为一个十进制的无符号整数。

!!! example **例** 当译解作为无符号整数保存在内存中的位串00101011时，从输出设备返回什么？

    解 二进制整数转换为十进制无符号整数43。


**(3) 溢出**

因为大小（即存储单元的位的数量）的限制，可以表达的整数范围是有限的。在n位存储单元中，我们可以存储的无符号整数仅为0到$2^n - 1$之间。


### 原码、反码和补码 <!-- HA -->

在上一节的表格中我们发现，所有整数类型能够表示的负数都比正数多一个，例如 `byte` 的取值范围是 $[-128, 127]$ 。这个现象比较反直觉，它的内在原因涉及原码、反码、补码的相关知识。

首先需要指出，**数字是以“补码”的形式存储在计算机中的**。在分析这样做的原因之前，首先给出三者的定义。

- **原码**：我们将数字的二进制表示的最高位视为符号位，其中 $0$ 表示正数，$1$ 表示负数，其余位表示数字的值。
- **反码**：正数的反码与其原码相同，负数的反码是对其原码除符号位外的所有位取反。
- **补码**：正数的补码与其原码相同，负数的补码是在其反码的基础上加 $1$ 。

下图展示了原码、反码和补码之间的转换方法。

![原码、反码与补码之间的相互转换](CT2x.assets/CT21--1s_2s_complement.png)

<u>原码（sign-magnitude）</u>虽然最直观，但存在一些局限性。一方面，**负数的原码不能直接用于运算**。例如在原码下计算 $1 + (-2)$ ，得到的结果是 $-3$ ，这显然是不对的。

$$
\begin{aligned}
& 1 + (-2) \newline
& \rightarrow 0000 \; 0001 + 1000 \; 0010 \newline
& = 1000 \; 0011 \newline
& \rightarrow -3
\end{aligned}
$$

为了解决此问题，计算机引入了<u>反码（1's complement）</u>。如果我们先将原码转换为反码，并在反码下计算 $1 + (-2)$ ，最后将结果从反码转换回原码，则可得到正确结果 $-1$ 。

$$
\begin{aligned}
& 1 + (-2) \newline
& \rightarrow 0000 \; 0001 \; \text{(原码)} + 1000 \; 0010 \; \text{(原码)} \newline
& = 0000 \; 0001 \; \text{(反码)} + 1111  \; 1101 \; \text{(反码)} \newline
& = 1111 \; 1110 \; \text{(反码)} \newline
& = 1000 \; 0001 \; \text{(原码)} \newline
& \rightarrow -1
\end{aligned}
$$

另一方面，**数字零的原码有 $+0$ 和 $-0$ 两种表示方式**。这意味着数字零对应两个不同的二进制编码，这可能会带来歧义。比如在条件判断中，如果没有区分正零和负零，则可能会导致判断结果出错。而如果我们想处理正零和负零歧义，则需要引入额外的判断操作，这可能会降低计算机的运算效率。

$$
\begin{aligned}
+0 & \rightarrow 0000 \; 0000 \newline
-0 & \rightarrow 1000 \; 0000
\end{aligned}
$$

与原码一样，反码也存在正负零歧义问题，因此计算机进一步引入了<u>补码（2's complement）</u>。我们先来观察一下负零的原码、反码、补码的转换过程：

$$
\begin{aligned}
-0 \rightarrow \; & 1000 \; 0000 \; \text{(原码)} \newline
= \; & 1111 \; 1111 \; \text{(反码)} \newline
= 1 \; & 0000 \; 0000 \; \text{(补码)} \newline
\end{aligned}
$$

在负零的反码基础上加 $1$ 会产生进位，但 `byte` 类型的长度只有 8 位，因此溢出到第 9 位的 $1$ 会被舍弃。也就是说，**负零的补码为 $0000 \; 0000$ ，与正零的补码相同**。这意味着在补码表示中只存在一个零，正负零歧义从而得到解决。

还剩最后一个疑惑：`byte` 类型的取值范围是 $[-128, 127]$ ，多出来的一个负数 $-128$ 是如何得到的呢？我们注意到，区间 $[-127, +127]$ 内的所有整数都有对应的原码、反码和补码，并且原码和补码之间可以互相转换。

然而，**补码 $1000 \; 0000$ 是一个例外，它并没有对应的原码**。根据转换方法，我们得到该补码的原码为 $0000 \; 0000$ 。这显然是矛盾的，因为该原码表示数字 $0$ ，它的补码应该是自身。计算机规定这个特殊的补码 $1000 \; 0000$ 代表 $-128$ 。实际上，$(-1) + (-127)$ 在补码下的计算结果就是 $-128$ 。

$$
\begin{aligned}
& (-127) + (-1) \newline
& \rightarrow 1111 \; 1111 \; \text{(原码)} + 1000 \; 0001 \; \text{(原码)} \newline
& = 1000 \; 0000 \; \text{(反码)} + 1111  \; 1110 \; \text{(反码)} \newline
& = 1000 \; 0001 \; \text{(补码)} + 1111  \; 1111 \; \text{(补码)} \newline
& = 1000 \; 0000 \; \text{(补码)} \newline
& \rightarrow -128
\end{aligned}
$$

你可能已经发现了，上述所有计算都是加法运算。这暗示着一个重要事实：**计算机内部的硬件电路主要是基于加法运算设计的**。这是因为加法运算相对于其他运算（比如乘法、除法和减法）来说，硬件实现起来更简单，更容易进行并行化处理，运算速度更快。

请注意，这并不意味着计算机只能做加法。**通过将加法与一些基本逻辑运算结合，计算机能够实现各种其他的数学运算**。例如，计算减法 $a - b$ 可以转换为计算加法 $a + (-b)$ ；计算乘法和除法可以转换为计算多次加法或减法。

现在我们可以总结出计算机使用补码的原因：基于补码表示，计算机可以用同样的电路和操作来处理正数和负数的加法，不需要设计特殊的硬件电路来处理减法，并且无须特别处理正负零的歧义问题。这大大简化了硬件设计，提高了运算效率。

补码的设计非常精妙，因篇幅关系我们就先介绍到这里，建议有兴趣的读者进一步深入了解。

### 二进制补码表示法

几乎所有的计算机都使用二进制补码表示法来存储位于n位存储单元中的有符号整数。这一方法中，无符号整数的有效范围（0到 $2^n - 1$）被分为2个相等的子范围。第一个子范围用来表示非负整数，第2个子范围用于表示负整数。例如，如果n是4，该范围是0000到1111。这个范围分为两半：0000到0111以及1000到1111。

尽管整数的符号影响二进制整数存储时的每一位，但是首位（最左位）决定符号。如果最左位是0，该整数非负；如果最左位是1，该整数是负数。

**在二进制补码表示法中，最左位决定符号。如果它是0，该整数为正，如果是1，该整数为负。**

**(1) 两种运算 Two operations **

在深入讨论这种表示法之前，我们需要介绍两种运算。第一种称为<mark>反码</mark>或取一个整数的反码。该运算可以应用到任何整数，无论是正的还是负的。该运算简单反转各个位，即把0位变为1位，把1位变为0位。

**例** 下面显示如何取整数00110110的反码。

​	原来的模式：	0 0 1 1 0 1 1 0

​	进行反码运算：    1 1 0 0 1 0 0 1



**例** 下面显示如果进行2次反码运算，就可以得到原先的整数。

​	原来的模式：	  0 0 1 1 0 1 1 0

​	进行1次反码运算：1 1 0 0 1 0 0 1

​	进行2次反码运算：0 0 1 1 0 1 1 0


第2种运算称为二进制中的<mark>补码</mark>或取一个整数的补码。该运算分为两步：首先，从右边复制位，直到有1被复制；接着，反转其余的位。



**例** 下面显示如何取整数00110100的补码。

​	原来的模式：	  0 0 1 1 0 1 0 0

​	进行1次补码运算：1 1 0 0 1 1 0 0

> 目前讲的是补码的运算，还没有到二进制存储，所以暂时不考虑正负，只考虑运算。



**例** 下面显示我们如果进行2次补码运算，就可以得到原先的整数。

​	原来的模式：	  0 0 1 1 0 1 0 0

​	进行1次补码运算：1 1 0 0 1 1 0 0

​	进行2次补码运算：0 0 1 1 0 1 0 0

另一种<mark>将一个整数进行补码运算的方法是先对它进行1次反码运算再加上1得到结果</mark>



**(2) 以二进制补码格式存储整数Storing an integer in two’s complement format**

以二进制补码格式存储整数，计算机遵循以下步骤：

- 将整数变成n位的二进制数。

- 如果整数是正数或零，以其原样存储；<mark>如果是负数，计算机取其补码存储。</mark>

**(3) 从二进制补码格式还原整数**Retrieving an integer in two’s complement format

从二进制补码格式还原整数，计算机遵循以下步骤：

- 如果最左位是1，计算机取其补码。如果最左位是0，计算机不进行操作。
- 计算机将该整数转换为十进制。


**例** 用二进制补码表示法将整数 28 存储在 8 位存储单元中。

解 该整数是正数（无符号意思是正的），因此在把该整数从十进制转换成二进制后不再需要其他操作。注意，5个多余的零加到该整数的左边使其成为8位。

​	把28变为8位的二进制：0 0 0 1 1 1 0 0



**例** 用二进制补码表示法将整数 -28 存储在 8 位存储单元中。

解 该整数是负数，因此在转换成二进制后计算机对其进行二进制补码运算。

​	把28变为8位的二进制：0 0 0 1 1 1 0 0

​	进行补码运算：	      1 1 1 0 0 1 0 0



**例** 用二进制补码表示法将存储在 8 位存储单元中的 00001101 还原成整数。

解 最左位是0，因此符号为正。该整数需要转换为十进制并加上符号即可。

## 实数

**实数**是带有整数部分和小数部分的数字。对于小数点，计算机使用两种不同的表示方法：<mark>定点和浮点</mark>。第一种用于把数字作为整数存储——没有小数部分，第二种把数字作为实数存储——带有小数部分。

例如：23.7是一个实数（整数部分是23而小数部分是7/10）。尽管固定小数点的表示法可用于表示实数，但结果不一定精确或达不到需要的精度。以下两个例子说明了原因。

**例** 在十进制系统中，假定用一种小数点右边2个数码，左边14个数码，总共16个数码的定点表示法。那么如果试图表示十进制数1.002 34，该系统的实数精度就会受损。该系统把这个数字存储为1.00。

**例** 在十进制系统中，假定用一种小数点右边6个数码，左边10个数码，总共16个数码的定点表示法。那么如果试图表示十进制数236 154 302 345.00，该系统的实数精度就会受损。该系统把这个数字存储为6 154 302 345.00。整数部分比实际小了很多。

**带有很大的整数部分或很小的小数部分的实数不应该用定点表示法存储。**

### 浮点数编码 <!-- HA -->

细心的你可能会发现：`int` 和 `float` 长度相同，都是 4 字节 ，但为什么 `float` 的取值范围远大于 `int` ？这非常反直觉，因为按理说 `float` 需要表示小数，取值范围应该变小才对。

实际上，**这是因为浮点数 `float` 采用了不同的表示方式**。记一个 32 比特长度的二进制数为：

$$
b_{31} b_{30} b_{29} \ldots b_2 b_1 b_0
$$

根据 IEEE 754 标准，32-bit 长度的 `float` 由以下三个部分构成。

- 符号位 $\mathrm{S}$ ：占 1 位 ，对应 $b_{31}$ 。
- 指数位 $\mathrm{E}$ ：占 8 位 ，对应 $b_{30} b_{29} \ldots b_{23}$ 。
- 分数位 $\mathrm{N}$ ：占 23 位 ，对应 $b_{22} b_{21} \ldots b_0$ 。

二进制数 `float` 对应值的计算方法为：

$$
\text {val} = (-1)^{b_{31}} \times 2^{\left(b_{30} b_{29} \ldots b_{23}\right)_2-127} \times\left(1 . b_{22} b_{21} \ldots b_0\right)_2
$$

转化到十进制下的计算公式为：

$$
\text {val}=(-1)^{\mathrm{S}} \times 2^{\mathrm{E} -127} \times (1 + \mathrm{N})
$$

其中各项的取值范围为：

$$
\begin{aligned}
\mathrm{S} \in & \{ 0, 1\}, \quad \mathrm{E} \in \{ 1, 2, \dots, 254 \} \newline
(1 + \mathrm{N}) = & (1 + \sum_{i=1}^{23} b_{23-i} 2^{-i}) \subset [1, 2 - 2^{-23}]
\end{aligned}
$$

![IEEE 754 标准下的 float 的计算示例](CT2x.assets/CT21--ieee_754_float.png)

观察上图，给定一个示例数据 $\mathrm{S} = 0$ ， $\mathrm{E} = 124$ ，$\mathrm{N} = 2^{-2} + 2^{-3} = 0.375$ ，则有：

$$
\text { val } = (-1)^0 \times 2^{124 - 127} \times (1 + 0.375) = 0.171875
$$

现在我们可以回答最初的问题：**`float` 的表示方式包含指数位，导致其取值范围远大于 `int`** 。根据以上计算，`float` 可表示的最大正数为 $2^{254 - 127} \times (2 - 2^{-23}) \approx 3.4 \times 10^{38}$ ，切换符号位便可得到最小负数。

**尽管浮点数 `float` 扩展了取值范围，但其副作用是牺牲了精度**。整数类型 `int` 将全部 32 比特用于表示数字，数字是均匀分布的；而由于指数位的存在，浮点数 `float` 的数值越大，相邻两个数字之间的差值就会趋向越大。

如下表所示，指数位 $\mathrm{E} = 0$ 和 $\mathrm{E} = 255$ 具有特殊含义，**用于表示零、无穷大、$\mathrm{NaN}$ 等**。

<p align="center"> 表 <id> &nbsp; 指数位含义 </p>

| 指数位 E           | 分数位 $\mathrm{N} = 0$ | 分数位 $\mathrm{N} \ne 0$ | 计算公式                                                               |
| ------------------ | ----------------------- | ------------------------- | ---------------------------------------------------------------------- |
| $0$                | $\pm 0$                 | 次正规数                  | $(-1)^{\mathrm{S}} \times 2^{-126} \times (0.\mathrm{N})$              |
| $1, 2, \dots, 254$ | 正规数                  | 正规数                    | $(-1)^{\mathrm{S}} \times 2^{(\mathrm{E} -127)} \times (1.\mathrm{N})$ |
| $255$              | $\pm \infty$            | $\mathrm{NaN}$            |                                                                        |

值得说明的是，次正规数显著提升了浮点数的精度。最小正正规数为 $2^{-126}$ ，最小正次正规数为 $2^{-126} \times 2^{-23}$ 。

双精度 `double` 也采用类似于 `float` 的表示方法，在此不做赘述。

### 浮点表示法

用于维持正确度或精度的解决方法是使用<mark>浮点表示法</mark>。该表示法允许小数点浮动：我们可以在小数点的左右有不同数量的数码。使用这种方法极大地增加了可存储的实数范围：带有很大的整数部分或很小的小数部分的实数可以存储在内存中。在浮点表示法中，无论十进制还是二进制，一个数字都由3部分组成。

​	符号	位移量	定点数	

第一部分是符号，可正可负。第二部分显示小数点应该左右移动构成实际数字的位移量。第三部分是小数点位置固定的定点表示法。



**一个数字的浮点表示法由3部分组成：符号、位移量和定点数。**



浮点表示法在科学中用于表示很小或很大的十进制数。在称作科学记数法的表示法中，定点部分在小数点左边只有1个数码而且位移量是10的幂次。



**例** 下面演示用科学记数法(浮点表示法)表示的十进制数7 425 000 000 000 000 000 000.00。

解

​	实际数字 → + 7 425 000 000 000 000 000 000.00

​	科学记数法 → + 7.425 × $10^{21}$

这三部分为符号 (+)、位移量 (21) 以及定点部分 (7.425)。注意那个位移量就是指数。这种表示法的好处显而易见。即使在一张纸上写数字，科学记数法也是更短并更省空间。这种记数法使用了浮点表示法的概念，因为那个靠近例题右下方的小数点位置已经向左移了21位形成该数字的定点部分。一些程序设计语言和计算器按照 +7.425E21来显示该数字，因为以10为底是不言而喻的。



**例** 用科学记数法表示数字-0.000 000 000 000 023 2。

解 使用前例同样的方法，将小数点移到数码2之后，如下所示：

​	实际数字 	→ - 0.000 000 000 000 023 2

​	科学记数法     → - 2.32 × $10^{-14}$

注意这里指数是负的，因为小数点需要左移（14位）来构成原数字。我们可再次说该记数法中的数字由3部分组成：符号（-）、实数（2.32）以及负整数（-14）。一些程序设计语言和计算器按照-2.32E-14来显示该数字。



<mark>类似方法可用于表示很小或很大的存储于计算机中的二进制数字（整数和实数皆可）。</mark>

**例** 用浮点格式表示数字$(101001000000000000000000000000000.00)_2$。

解 使用前例同样的方法，小数点前只保留一位数字，如下所示：

​	实际数字 	→ + $(101001000000000000000000000000000.00)_2$

​	科学记数法     → + 1.01001 × $2^{32}$

注意我们不必担心从最右边的1开始的右侧的那些0，这是因为当我们使用实数 $(1.01001)_2$时它们并不重要。指数显示为32，但它实际上以二进制存储在计算机中。我们也已经显示符号为正，但它可能作为1位存储。



**例** 用浮点格式表示数字$-(0.00000000000000000000000101)_2$。

解 使用前例同样的方法，小数点左边只留一个非零数码：

​	实际数字 	→ $- (0.00000000000000000000000101)_2$

​	科学记数法.    → $- 1.01 × 2^{-24}$

注意指数作为负的二进制数存储在计算机中。



### 规范化

为了使表示法的固定部分统一，科学记数法（用于十进制）和浮点表示法（用于二进制）都在小数点左边使用了唯一的非零数码，这称为规范化。十进制系统中的数码可能是1到9，而二进制系统中该数码是1。在下面，d是非零数码，x是一个数码，y是0或1。

​	十进制 → ± d.xxxxxxxxxxxxxxx 注意：d是1到9，每个x是0到9

​	二进制 → ± 1.yyyyyyyyyyyy 注意：每个y是0或1



### 符号、指数和尾数

在一个二进制数规范化之后，我们只存储了该数的3部分信息：符号、指数和尾数（小数点右边的位）。

例如，+1000111.0101规范化后变成为：

​	$+\quad \quad 2^6 \quad \times \quad 1.0001110101 $

​	$+\quad \quad 6 \quad \quad \quad \quad 0001110101 $

​	$
\begin{array}{ccc}
\uparrow & \uparrow & & \uparrow \\
\text{符号} & \text{指数} & & \text{尾数}
\end{array}
​	$

**注意小数点和定点部分左边的位1并没有存储，它们是隐含的。**

(1) 符号

一个数的符号可以用一个二进制位来存储（0或1）。

(2) 指数

指数（2的幂）定义为小数点移动的位数。注意幂可以为正也可以为负。余码表示法（后面讨论）是用来存储指数位的方法。

(3) 尾数

尾数是指小数点右边的二进制数。它定义了该数的精度。尾数是作为无符号整数存储的。如果我们把尾数和符号一起考虑，则可以说这个组合是作为符号加绝对值格式的整数存储的。

**尾数是带符号的小数部分，可以像以符号加绝对值表示法存储的整数那样对待。**



电气和电子工程师协会(IEEE)已定义了几种存储浮点数的标准。这里我们讨论其中两种最常用的--单精度和双精度。
