# 数算一体

- **计算机** 是一个计算工具，它本身不能主动帮助我们做任何事情，需要我们告诉它如何进行计算。
- **程序设计** 就是要告诉计算机如何进行计算的。这与我们中学时代的数学解题过程是一样的，只不过描述的手段有所变化而已。
- **算法** 是在有限时间内解决特定问题的一组指令或操作步骤，而 **数据结构** 是计算机中组织和存储数据的方式。
- 数据结构与算法密不可分：数据结构是算法的基石，而算法为数据结构注入生命力。

---

- **算法** ，顾名思义，即计算的方法；广义地说，为解决一个问题而采取的方法和步骤
  - 算法通常用于解决特定的计算任务，但与可以直接在计算机上运行的程序不同，算法使用数学化的描述，更加侧重于思想，可以被看作抽象的程序。
  - 同一个算法可以有许多种不同的实现方式，两个不同的程序里也可能使用了同一种算法。
  - 对同一个问题，可以有不同的算法，即不同的解题方法和步骤。
  - 为了有效地进行解题，不仅需要保证算法正确，还要考虑算法的质量，选择合适的算法。 
- 常用算法一般都被实现为 **算法库** ，供程序员调用。

## 算法无处不在

当我们听到“算法”这个词时，很自然地会想到数学。然而实际上，许多算法并不涉及复杂数学，而是更多地依赖基本逻辑，这些逻辑在我们的日常生活中处处可见。

在正式探讨算法之前，有一个有趣的事实值得分享：**你已经在不知不觉中学会了许多算法，并习惯将它们应用到日常生活中了**。下面我将举几个具体的例子来证实这一点。

**例一：查字典**。在字典里，每个汉字都对应一个拼音，而字典是按照拼音字母顺序排列的。假设我们需要查找一个拼音首字母为 $r$ 的字，通常会按照下图所示的方式实现。

1. 翻开字典约一半的页数，查看该页的首字母是什么，假设首字母为 $m$ 。
2. 由于在拼音字母表中 $r$ 位于 $m$ 之后，所以排除字典前半部分，查找范围缩小到后半部分。
3. 不断重复步骤 `1.` 和步骤 `2.` ，直至找到拼音首字母为 $r$ 的页码为止。

=== "<1>"
    ![查字典步骤](DA1x.assets/DSA--binary_search_dictionary_step1.png)

=== "<2>"
    ![binary_search_dictionary_step2](DA1x.assets/DSA--binary_search_dictionary_step2.png)

=== "<3>"
    ![binary_search_dictionary_step3](DA1x.assets/DSA--binary_search_dictionary_step3.png)

=== "<4>"
    ![binary_search_dictionary_step4](DA1x.assets/DSA--binary_search_dictionary_step4.png)

=== "<5>"
    ![binary_search_dictionary_step5](DA1x.assets/DSA--binary_search_dictionary_step5.png)

查字典这个小学生必备技能，实际上就是著名的“二分查找”算法。从数据结构的角度，我们可以把字典视为一个已排序的“数组”；从算法的角度，我们可以将上述查字典的一系列操作看作“二分查找”。

**例二：整理扑克**。我们在打牌时，每局都需要整理手中的扑克牌，使其从小到大排列，实现流程如下图所示。

1. 将扑克牌划分为“有序”和“无序”两部分，并假设初始状态下最左 1 张扑克牌已经有序。
2. 在无序部分抽出一张扑克牌，插入至有序部分的正确位置；完成后最左 2 张扑克已经有序。
3. 不断循环步骤 `2.` ，每一轮将一张扑克牌从无序部分插入至有序部分，直至所有扑克牌都有序。

![扑克排序步骤](DA1x.assets/DSA--playing_cards_sorting.png)

上述整理扑克牌的方法本质上是“插入排序”算法，它在处理小型数据集时非常高效。许多编程语言的排序库函数中都有插入排序的身影。

**例三：货币找零**。假设我们在超市购买了 $69$ 元的商品，给了收银员 $100$ 元，则收银员需要找我们 $31$ 元。他会很自然地完成如下图所示的思考。

1. 可选项是比 $31$ 元面值更小的货币，包括 $1$ 元、$5$ 元、$10$ 元、$20$ 元。
2. 从可选项中拿出最大的 $20$ 元，剩余 $31 - 20 = 11$ 元。
3. 从剩余可选项中拿出最大的 $10$ 元，剩余 $11 - 10 = 1$ 元。
4. 从剩余可选项中拿出最大的 $1$ 元，剩余 $1 - 1 = 0$ 元。
5. 完成找零，方案为 $20 + 10 + 1 = 31$ 元。

![货币找零过程](DA1x.assets/DSA--greedy_change.png)

在以上步骤中，我们每一步都采取当前看来最好的选择（尽可能用大面额的货币），最终得到了可行的找零方案。从数据结构与算法的角度看，这种方法本质上是“贪心”算法。

小到烹饪一道菜，大到星际航行，几乎所有问题的解决都离不开算法。计算机的出现使得我们能够通过编程将数据结构存储在内存中，同时编写代码调用 CPU 和 GPU 执行算法。这样一来，我们就能把生活中的问题转移到计算机上，以更高效的方式解决各种复杂问题。

## 数算基本概念

### 算法定义

!!! quote 算法
    “算法”（Algorithm）一词源于阿拉伯数学家阿科瓦里茨米（AlKhowarizmi），其在公元825年写了著名的《波斯教科书》（Persian Textbook），书中概括了进行四则算术运算的计算规则。

**算法** 是一个有穷规则的集合，它用规则规定了解决某一特定类型问题的运算序列，或者规定了任务执行或问题求解的一系列步骤。

!!! info https://en.wikipedia.org/wiki/Algorithm#Definition

    Harold S. Stone 给出的一种非正式定义是 `a set of rules that precisely defines a sequence of operations`（一套精确定义操作序列的规则），这一定义涵盖所有计算机程序（包括不执行数值计算的程序），以及任何规定的官僚程序或食谱。

    一般来说，一个程序只有最终会停止，才是算法 ———— 尽管无限循环有时可能是可取的。
    
    Boolos、Jeffrey 将算法定义为 `an explicit set of instructions for determining an output, that can be followed by a computing machine or a human who could only carry out specific elementary operations on symbols` （一套用于确定输出的明确指令集，这套指令可由仅能对符号执行特定基本操作的计算机器或人类遵循）

算法的五个特征：

- **有穷性**：一个算法在执行有穷步规则之后必须结束。
- **确定性**：算法的每一个步骤必须要确切地定义，不得有歧义性。
- **输入**：算法有零个或多个的输入。
- **输出**：算法有一个或多个的输出/结果，即与输入有某个特定关系的量。
- **有效性**：算法中有待执行的运算和操作必须是相当基本的(可以由机器自动完成)，并能在有限时间内完成。

算法的基本评价：

- **正确性**：算法必须能够正确地解决问题，即对给定的输入，能够产生期望的输出。
- **易维护**：算法的代码应该易于理解和维护，以便后续的修改和调试。
- **方便使用**：算法应该提供简洁的接口，使用户能够方便地调用和使用。
- **高效**：算法在执行过程中应该能够利用计算机的资源，以最短的时间和最少的内存空间完成任务。

### 数据结构定义

<u>数据结构（data structure）</u>是组织和存储数据的方式，涵盖数据内容、数据之间关系和数据操作方法，它具有以下设计目标。

- 空间占用尽量少，以节省计算机内存。
- 数据操作尽可能快速，涵盖数据访问、添加、删除、更新等。
- 提供简洁的数据表示和逻辑信息，以便算法高效运行。

**数据结构设计是一个充满权衡的过程**。如果想在某方面取得提升，往往需要在另一方面作出妥协。下面举两个例子。

- 链表相较于数组，在数据添加和删除操作上更加便捷，但牺牲了数据访问速度。
- 图相较于链表，提供了更丰富的逻辑信息，但需要占用更大的内存空间。

### 数据结构与算法的关系

如下图所示，数据结构与算法高度相关、紧密结合，具体表现在以下三个方面。

- 数据结构是算法的基石。数据结构为算法提供了结构化存储的数据，以及操作数据的方法。
- 算法为数据结构注入生命力。数据结构本身仅存储数据信息，结合算法才能解决特定问题。
- 算法通常可以基于不同的数据结构实现，但执行效率可能相差很大，选择合适的数据结构是关键。

![数据结构与算法的关系](DA1x.assets/DSA--relationship_between_data_structure_and_algorithm.png)

数据结构与算法犹如下图所示的拼装积木。一套积木，除了包含许多零件之外，还附有详细的组装说明书。我们按照说明书一步步操作，就能组装出精美的积木模型。

![拼装积木](DA1x.assets/DSA--assembling_blocks.png)

两者的详细对应关系如下表所示。

<p align="center"> 表 <id> &nbsp; 将数据结构与算法类比为拼装积木 </p>

| 数据结构与算法 | 拼装积木                                 |
| -------------- | ---------------------------------------- |
| 输入数据       | 未拼装的积木                             |
| 数据结构       | 积木组织形式，包括形状、大小、连接方式等 |
| 算法           | 把积木拼成目标形态的一系列操作步骤       |
| 输出数据       | 积木模型                                 |

值得说明的是，数据结构与算法是独立于编程语言的。正因如此，本书得以提供基于多种编程语言的实现。

!!! tip "约定俗成的简称"

    在实际讨论时，我们通常会将“数据结构与算法”简称为“算法”。比如众所周知的 LeetCode 算法题目，实际上同时考查数据结构和算法两方面的知识。

!!! abstract 数据结构 + 算法 = 程序

    Niklaus Wirth 在 1976 年出版了同名专著《Algorithms + Data Structures = Programs》，书中系统阐述了数据结构与算法的共生关系，并提出这一公式作为程序设计的核心逻辑：

    - 数据结构是程序的“骨架”（组织数据的静态框架）；
    - 算法是程序的“灵魂”（操作数据的动态逻辑）；
    - 二者的结合构成了完整的可执行程序。

    这一论断奠定了计算机科学中“程序设计的本质是对数据与操作的抽象”这一核心思想，至今仍是计算机教育的基石之一。

## 数据结构无处不在

!!! note 数据结构无处不在：

    - 大到社会网络，小到地铁线路，许多系统都可以建模为“图”；
    - 大到一个国家，小到一个家庭，社会的主要组织形式呈现出“树”的特征；
    - 冬天的衣服就像“栈”，最先穿上的最后才能脱下；
    - 羽毛球筒则如同“队列”，一端放入、另一端取出；
    - 字典就像一个“哈希表”，能够快速查找目标词条。

### 数据结构分类

常见的数据结构包括数组、链表、栈、队列、哈希表、树、堆、图，它们可以从“逻辑结构”和“物理结构”两个维度进行分类。

#### 逻辑结构：线性与非线性

**逻辑结构揭示了数据元素之间的逻辑关系**。在数组和链表中，数据按照一定顺序排列，体现了数据之间的线性关系；而在树中，数据从顶部向下按层次排列，表现出“祖先”与“后代”之间的派生关系；图则由节点和边构成，反映了复杂的网络关系。

如下图所示，逻辑结构可分为“线性”和“非线性”两大类。线性结构比较直观，指数据在逻辑关系上呈线性排列；非线性结构则相反，呈非线性排列。

- **线性数据结构**：数组、链表、栈、队列、哈希表，元素之间是一对一的顺序关系。
- **非线性数据结构**：树、堆、图、哈希表。

非线性数据结构可以进一步划分为树形结构和网状结构。

- **树形结构**：树、堆、哈希表，元素之间是一对多的关系。
- **网状结构**：图，元素之间是多对多的关系。

![线性数据结构与非线性数据结构](DA1x.assets/DS--classification_logic_structure.png)

#### 物理结构：连续与分散

**当算法程序运行时，正在处理的数据主要存储在内存中**。下图展示了一个计算机内存条，其中每个黑色方块都包含一块内存空间。我们可以将内存想象成一个巨大的 Excel 表格，其中每个单元格都可以存储一定大小的数据。

**系统通过内存地址来访问目标位置的数据**。如下图所示，计算机根据特定规则为表格中的每个单元格分配编号，确保每个内存空间都有唯一的内存地址。有了这些地址，程序便可以访问内存中的数据。

![内存条、内存空间、内存地址](DA1x.assets/DS--computer_memory_location.png)

!!! tip

    值得说明的是，将内存比作 Excel 表格是一个简化的类比，实际内存的工作机制比较复杂，涉及地址空间、内存管理、缓存机制、虚拟内存和物理内存等概念。

内存是所有程序的共享资源，当某块内存被某个程序占用时，则通常无法被其他程序同时使用了。**因此在数据结构与算法的设计中，内存资源是一个重要的考虑因素**。比如，算法所占用的内存峰值不应超过系统剩余空闲内存；如果缺少连续大块的内存空间，那么所选用的数据结构必须能够存储在分散的内存空间内。

如下图所示，**物理结构反映了数据在计算机内存中的存储方式**，可分为连续空间存储（数组）和分散空间存储（链表）。物理结构从底层决定了数据的访问、更新、增删等操作方法，两种物理结构在时间效率和空间效率方面呈现出互补的特点。

![连续空间存储与分散空间存储](DA1x.assets/DS--classification_phisical_structure.png)

值得说明的是，**所有数据结构都是基于数组、链表或二者的组合实现的**。例如，栈和队列既可以使用数组实现，也可以使用链表实现；而哈希表的实现可能同时包含数组和链表。

- **基于数组可实现**：栈、队列、哈希表、树、堆、图、矩阵、张量（维度 $\geq 3$ 的数组）等。
- **基于链表可实现**：栈、队列、哈希表、树、堆、图等。

链表在初始化后，仍可以在程序运行过程中对其长度进行调整，因此也称“动态数据结构”。数组在初始化后长度不可变，因此也称“静态数据结构”。值得注意的是，数组可通过重新分配内存实现长度变化，从而具备一定的“动态性”。

### 基本数据类型

当谈及计算机中的数据时，我们会想到文本、图片、视频、语音、3D 模型等各种形式。尽管这些数据的组织形式各异，但它们都由各种基本数据类型构成。

**基本数据类型是 CPU 可以直接进行运算的类型**，在算法中直接被使用，主要包括以下几种。

- 整数类型 `byte`、`short`、`int`、`long` 。
- 浮点数类型 `float`、`double` ，用于表示小数。
- 字符类型 `char` ，用于表示各种语言的字母、标点符号甚至表情符号等。
- 布尔类型 `bool` ，用于表示“是”与“否”判断。

**基本数据类型以二进制的形式存储在计算机中**。一个二进制位即为 $1$ 比特。在绝大多数现代操作系统中，$1$ 字节（byte）由 $8$ 比特（bit）组成。

基本数据类型的取值范围取决于其占用的空间大小。下面以 Java 为例。

- 整数类型 `byte` 占用 $1$ 字节 = $8$ 比特 ，可以表示 $2^{8}$ 个数字。
- 整数类型 `int` 占用 $4$ 字节 = $32$ 比特 ，可以表示 $2^{32}$ 个数字。

下表列举了 Java 中各种基本数据类型的占用空间、取值范围和默认值。此表格无须死记硬背，大致理解即可，需要时可以通过查表来回忆。

<p align="center"> 表 <id> &nbsp; 基本数据类型的占用空间和取值范围 </p>

| 类型   | 符号     | 占用空间 | 最小值                   | 最大值                  | 默认值         |
| ------ | -------- | -------- | ------------------------ | ----------------------- | -------------- |
| 整数   | `byte`   | 1 字节   | $-2^7$ ($-128$)          | $2^7 - 1$ ($127$)       | $0$            |
|        | `short`  | 2 字节   | $-2^{15}$                | $2^{15} - 1$            | $0$            |
|        | `int`    | 4 字节   | $-2^{31}$                | $2^{31} - 1$            | $0$            |
|        | `long`   | 8 字节   | $-2^{63}$                | $2^{63} - 1$            | $0$            |
| 浮点数 | `float`  | 4 字节   | $1.175 \times 10^{-38}$  | $3.403 \times 10^{38}$  | $0.0\text{f}$  |
|        | `double` | 8 字节   | $2.225 \times 10^{-308}$ | $1.798 \times 10^{308}$ | $0.0$          |
| 字符   | `char`   | 2 字节   | $0$                      | $2^{16} - 1$            | $0$            |
| 布尔   | `bool`   | 1 字节   | $\text{false}$           | $\text{true}$           | $\text{false}$ |

请注意，上表针对的是 Java 的基本数据类型的情况。每种编程语言都有各自的数据类型定义，它们的占用空间、取值范围和默认值可能会有所不同。

- 在 Python 中，整数类型 `int` 可以是任意大小，只受限于可用内存；浮点数 `float` 是双精度 64 位；没有 `char` 类型，单个字符实际上是长度为 1 的字符串 `str` 。
- C 和 C++ 未明确规定基本数据类型的大小，而因实现和平台各异。上表遵循 LP64 [数据模型](https://en.cppreference.com/w/cpp/language/types#Properties)，其用于包括 Linux 和 macOS 在内的 Unix 64 位操作系统。
- 字符 `char` 的大小在 C 和 C++ 中为 1 字节，在大多数编程语言中取决于特定的字符编码方法，详见“字符编码”章节。
- 即使表示布尔量仅需 1 位（$0$ 或 $1$），它在内存中通常也存储为 1 字节。这是因为现代计算机 CPU 通常将 1 字节作为最小寻址内存单元。

那么，基本数据类型与数据结构之间有什么联系呢？我们知道，数据结构是在计算机中组织与存储数据的方式。这句话的主语是“结构”而非“数据”。

如果想表示“一排数字”，我们自然会想到使用数组。这是因为数组的线性结构可以表示数字的相邻关系和顺序关系，但至于存储的内容是整数 `int`、小数 `float` 还是字符 `char` ，则与“数据结构”无关。

换句话说，**基本数据类型提供了数据的“内容类型”，而数据结构提供了数据的“组织方式”**。例如以下代码，我们用相同的数据结构（数组）来存储与表示不同的基本数据类型，包括 `int`、`float`、`char`、`bool` 等。

```python
class ListNode:
    """链表节点类"""
    def __init__(self, val: int):
        self.val: int = val  # 节点值
        self.next: ListNode | None = None  # 后继节点引用

"""Driver Code"""
if __name__ == "__main__":
    # 使用多种基本数据类型来初始化数组
    numbers = [0] * 5
    decimals = [0.0] * 5
    # Python 的字符实际上是长度为 1 的字符串
    characters = ['0'] * 5
    bools = [False] * 5
    # Python 的列表可以自由存储各种基本数据类型和对象引用
    data = [0, 0.0, 'a', False, ListNode(0)]
```

!!! example Python 可视化工具： https://pythontutor.com/visualize.html

# Q & A

!!! question 常用算法都被编程语言封装好了，直接用就可以了；为何还要学习算法的实现过程？

    如果把具体的工作技能比作是武功的“招式”的话，那么基础科目应该更像是“内功”。
    
    学算法（以及其他基础科目）的意义不是在于在工作中从零实现它，而是基于学到的知识，在解决问题时能够作出专业的反应和判断，从而提升工作的整体质量。举一个简单例子，每种编程语言都内置了排序函数：
    
    - 如果我们没有学过数据结构与算法，那么给定任何数据，我们可能都塞给这个排序函数去做了。运行顺畅、性能不错，看上去并没有什么问题。
    - 但如果学过算法，我们就会知道内置排序函数的时间复杂度是 $O(n \log n)$ ；而如果给定的数据是固定位数的整数（例如学号），那么我们就可以用效率更高的“基数排序”来做，将时间复杂度降为 $O(nk)$ ，其中 $k$ 为位数。当数据体量很大时，节省出来的运行时间就能创造较大价值（成本降低、体验变好等）。
    
    在实际应用领域中，大量问题是难以达到最优解的，许多问题只是被“差不多”地解决了。问题的难易程度一方面取决于问题本身的性质，另一方面也取决于观测问题的人的知识储备。人的知识越完备、经验越多，分析问题就会越深入，问题就能被解决得更优雅。
